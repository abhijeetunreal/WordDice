<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordFlow - Daily Vocabulary</title>
    <script type="module">
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0';
        window.transformersPipeline = pipeline;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 500px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .header {
            background: #4A90E2;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .date {
            font-size: 14px;
            opacity: 0.9;
        }

        .word-card {
            padding: 25px;
            text-align: center;
        }

        .word {
            font-size: 42px;
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
        }

        .pronunciation {
            color: #666;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .audio-btn {
            background: #50E3C2;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(80, 227, 194, 0.4);
            transition: transform 0.2s;
        }

        .audio-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .audio-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .audio-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .definition {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: left;
        }

        .definition h3 {
            color: #4A90E2;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .definition p {
            line-height: 1.6;
            color: #444;
        }

        .example {
            background: #f0f7ff;
            border-left: 4px solid #4A90E2;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            position: relative;
        }

        .example-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 10px;
        }

        .regenerate-btn {
            background: #4A90E2;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }

        .regenerate-btn:hover {
            background: #3a7bc8;
            transform: rotate(90deg);
        }

        .regenerate-btn:active {
            transform: rotate(180deg) scale(0.95);
        }

        .regenerate-btn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .regenerate-btn svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .example p {
            margin: 0;
            position: relative;
        }

        .example-text-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .skeleton-loader {
            display: none !important;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: #f0f7ff;
            opacity: 0;
            transition: opacity 0.1s ease;
        }

        .skeleton-loader.active {
            display: block !important;
            opacity: 1 !important;
        }

        .skeleton-line {
            height: 1.2em;
            background: linear-gradient(90deg, 
                #e0e0e0 25%, 
                #f0f0f0 50%, 
                #e0e0e0 75%);
            background-size: 200% 100%;
            border-radius: 4px;
            margin-bottom: 0.5em;
            animation: skeleton-shimmer 1.5s ease-in-out infinite;
        }

        .skeleton-line:last-child {
            margin-bottom: 0;
        }

        .skeleton-line.short {
            width: 60%;
        }

        .skeleton-line.medium {
            width: 80%;
        }

        .skeleton-line.long {
            width: 100%;
        }

        @keyframes skeleton-shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }

        .char-morph {
            display: inline-block;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .char-morph.morphing {
            opacity: 0.3;
            transform: scale(0.8);
        }

        .char-morph.morphing-in {
            animation: charMorphIn 0.4s ease forwards;
        }

        @keyframes charMorphIn {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-5px);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1) translateY(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .practice-section {
            padding: 0 25px 25px;
        }

        .practice-section h3 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .practice-btns {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .practice-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: #f0f7ff;
            color: #4A90E2;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .practice-btn:hover {
            background: #4A90E2;
            color: white;
        }

        .practice-btn.active {
            background: #4A90E2;
            color: white;
        }

        .practice-area {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .practice-text {
            font-size: 18px;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }

        .practice-instruction {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-bottom: 15px;
        }

        .record-btn {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .record-btn:hover {
            background: #3a7bc8;
        }

        .record-btn.recording {
            background: #e74c3c;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .transcript {
            margin-top: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            width: 100%;
            min-height: 60px;
            border: 1px solid #e0e0e0;
        }

        .transcript-text {
            font-style: italic;
            color: #555;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            border: 2px solid #4A90E2;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            font-family: inherit;
        }

        .input-field:focus {
            outline: none;
            border-color: #3a7bc8;
        }

        .textarea-field {
            width: 100%;
            padding: 12px;
            border: 2px solid #4A90E2;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
        }

        .textarea-field:focus {
            outline: none;
            border-color: #3a7bc8;
        }

        .submit-btn {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .submit-btn:hover {
            background: #3a7bc8;
        }

        .feedback {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .feedback.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .next-btn {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .next-btn:hover:not(:disabled) {
            background: #3a7bc8;
        }

        .next-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
        }

        .loading.show {
            opacity: 1;
        }

        .loading img {
            max-width: 200px;
            margin-bottom: 20px;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #e74c3c;
        }

        .browser-warning {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ffeaa7;
        }

        .hidden {
            display: none;
        }

        #word-container {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #word-container.show {
            opacity: 1;
        }

        @media (max-width: 500px) {
            .word {
                font-size: 36px;
            }

            .practice-btns {
                flex-direction: column;
            }

            .loading img {
                max-width: 64px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>WordDice</h1>
            <div class="date" id="current-date">Loading...</div>
        </div>

        <div id="loading" class="loading show">
            <img src="https://media.tenor.com/sUiwSBs8S6QAAAAj/dice-game.gif" alt="Loading animation">
            <p>Loading today's word...</p>
        </div>
    

        <div id="word-container" class="hidden">
            <div class="word-card">
                <div class="word" id="word">Serendipity</div>
                <div class="pronunciation" id="pronunciation">/ˌser.ənˈdɪp.ə.ti/</div>

                <button class="audio-btn" id="audio-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path
                            d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z">
                        </path>
                    </svg>
                </button>

                <div class="definition">
                    <h3>Definition</h3>
                    <p id="definition">The occurrence and development of events by chance in a happy or beneficial way.
                    </p>

                    <div class="example">
                        <div class="example-header">
                            <p id="example" style="flex: 1; margin: 0;">"A fortunate stroke of serendipity led them to discover the beautiful hidden
                                beach."</p>
                            <button class="regenerate-btn" id="regenerate-btn" title="Generate new example sentence">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="practice-section">
                <h3>Practice Using This Word</h3>

                <div id="browser-warning" class="browser-warning hidden">
                    Speech recognition works best in Chrome and Edge. Make sure you're in a quiet environment and allow
                    microphone access when prompted.
                </div>

                <div class="practice-btns">
                    <button class="practice-btn active" id="repeat-btn">Repeat Sentence</button>
                    <button class="practice-btn" id="fill-btn">Fill in Blank</button>
                    <button class="practice-btn" id="create-btn">Create Sentence</button>
                </div>

                <div class="practice-area">
                    <div class="practice-text" id="practice-text">
                        "A fortunate stroke of serendipity led them to discover the beautiful hidden beach."
                    </div>
                    <div class="practice-instruction" id="practice-instruction">
                        Click the record button and repeat the sentence above
                    </div>
                    <div id="recording-section">
                        <button class="record-btn" id="record-btn">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                                <path
                                    d="M8 12c2.21 0 4-1.79 4-4V4c0-2.21-1.79-4-4-4S4 1.79 4 4v4c0 2.21 1.79 4 4 4zm0 1c-2.76 0-5-2.24-5-5V4c0-2.76 2.24-5 5-5s5 2.24 5 5v4c0 2.76-2.24 5-5 5z" />
                                <path
                                    d="M0 7.5v1c0 .28.22.5.5.5H2v-2H.5c-.28 0-.5.22-.5.5zM16 7.5c0-.28-.22-.5-.5-.5H14v2h1.5c.28 0 .5-.22.5-.5v-1zM4.5 13.5c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5h1c.28 0 .5-.22.5-.5V14c0-.28-.22-.5-.5-.5h-1zM11.5 13.5c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5h1c.28 0 .5-.22.5-.5V14c0-.28-.22-.5-.5-.5h-1zM8 15c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5s.5-.22.5-.5v-1c0-.28-.22-.5-.5-.5z" />
                            </svg>
                            Start Recording
                        </button>
                        <div class="transcript">
                            <div class="transcript-text" id="transcript-text">Your speech will appear here...</div>
                        </div>
                    </div>
                    <div id="input-section" class="hidden">
                        <input type="text" class="input-field" id="practice-input"
                            placeholder="Type your answer here...">
                        <textarea class="textarea-field hidden" id="practice-textarea"
                            placeholder="Type your sentence here..."></textarea>
                        <button class="submit-btn" id="submit-btn">Submit</button>
                        <div id="feedback" class="feedback hidden"></div>
                    </div>
                </div>

                <div class="progress">
                    <button class="next-btn" id="next-btn">Next Word</button>
                </div>
            </div>

        </div>

        <div id="error" class="error hidden">
            <p>Sorry, we couldn't load today's word. Please try again later.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Elements
            const loadingEl = document.getElementById('loading');
            const wordContainerEl = document.getElementById('word-container');
            const errorEl = document.getElementById('error');
            const browserWarningEl = document.getElementById('browser-warning');
            const currentDateEl = document.getElementById('current-date');
            const wordEl = document.getElementById('word');
            const pronunciationEl = document.getElementById('pronunciation');
            const definitionEl = document.getElementById('definition');
            const exampleEl = document.getElementById('example');
            const regenerateBtn = document.getElementById('regenerate-btn');
            const audioBtn = document.getElementById('audio-btn');
            const nextBtn = document.getElementById('next-btn');
            const repeatBtn = document.getElementById('repeat-btn');
            const fillBtn = document.getElementById('fill-btn');
            const createBtn = document.getElementById('create-btn');
            const practiceTextEl = document.getElementById('practice-text');
            const practiceInstructionEl = document.getElementById('practice-instruction');
            const recordBtn = document.getElementById('record-btn');
            const transcriptTextEl = document.getElementById('transcript-text');
            const recordingSectionEl = document.getElementById('recording-section');
            const inputSectionEl = document.getElementById('input-section');
            const practiceInputEl = document.getElementById('practice-input');
            const practiceTextareaEl = document.getElementById('practice-textarea');
            const submitBtn = document.getElementById('submit-btn');
            const feedbackEl = document.getElementById('feedback');

            // Speech synthesis and recognition
            const synth = window.speechSynthesis;
            let recognition = null;
            let isRecording = false;
            let currentWord = null;
            let silenceTimeout = null;
            let lastSpeechTime = null;
            const SILENCE_TIMEOUT_MS = 3000; // 3 seconds of silence before auto-stop
            let regenerateCancelled = false; // Flag to cancel regeneration

            // Word list for fallback
            let wordList = [
                "serendipity", "eloquent", "resilient", "ephemeral", "lucid",
                "magnanimous", "ubiquitous", "voracious", "zenith", "nostalgia",
                "quintessential", "ambiguous", "diligent", "empathy", "frugal"
            ];

            // CSV word list management
            // Configure your CSV file URL here
            const CSV_URL = 'https://raw.githubusercontent.com/codefrydev/Data/refs/heads/main/Dictionary/CommonWords'; // Set your CSV file URL here, e.g., 'https://example.com/words.csv'
            
            let csvWords = [];
            let isCsvLoaded = false;

            // Local LLM for generating example sentences
            let llmPipeline = null;
            let llmLoading = false;
            let llmReady = false;

            // Initialize local LLM (non-blocking, runs in background)
            async function initializeLLM() {
                if (llmLoading || llmReady) return;
                
                try {
                    llmLoading = true;
                    console.log('Loading local LLM for sentence generation (non-blocking)...');
                    
                    // Wait for transformers pipeline to be available (with timeout)
                    if (typeof window.transformersPipeline === 'undefined') {
                        await new Promise(resolve => {
                            const checkTransformers = setInterval(() => {
                                if (typeof window.transformersPipeline !== 'undefined') {
                                    clearInterval(checkTransformers);
                                    resolve();
                                }
                            }, 100);
                            // Timeout after 5 seconds - don't wait too long
                            setTimeout(() => {
                                clearInterval(checkTransformers);
                                resolve();
                            }, 5000);
                        });
                    }
                    
                    if (typeof window.transformersPipeline === 'undefined') {
                        throw new Error('Transformers.js library not loaded');
                    }
                    
                    llmPipeline = await window.transformersPipeline(
                        'text-generation',
                        'Xenova/gpt2',
                        {
                            dtype: 'q8',
                        }
                    );
                    
                    llmReady = true;
                    llmLoading = false;
                    console.log('Local LLM loaded successfully');
                } catch (error) {
                    console.error('Error loading LLM:', error);
                    llmLoading = false;
                    llmReady = false; // Explicitly mark as not ready
                    // Continue without LLM, will use API examples
                }
            }

            // Generate example sentence using local LLM
            async function generateExampleSentence(word, definition) {
                if (!llmReady || !llmPipeline) {
                    return null;
                }

                try {
                    // Create a conversational prompt that guides the LLM to generate natural sentences
                    const prompt = `Write a natural, conversational sentence using the word "${word}" which means "${definition}". Make it sound like everyday speech:`;
                    
                    const output = await llmPipeline(prompt, {
                        max_new_tokens: 50,
                        temperature: 0.7,
                        do_sample: true,
                        top_k: 40,
                        top_p: 0.85,
                        repetition_penalty: 1.4,
                        pad_token_id: 50256,
                    });

                    let generatedText = output[0].generated_text;
                    
                    // Extract the sentence after the prompt
                    const promptIndex = generatedText.indexOf(prompt);
                    if (promptIndex !== -1) {
                        let sentence = generatedText.substring(promptIndex + prompt.length).trim();
                        
                        // Clean up the sentence
                        sentence = sentence.replace(/^["']|["']$/g, ''); // Remove quotes
                        // Remove any trailing incomplete words or fragments
                        sentence = sentence.split(/[.!?]/)[0]; // Take first complete sentence
                        sentence = sentence.trim();
                        
                        // Filter out weird or nonsensical sentences
                        // Check for minimum length and ensure it's a real sentence
                        if (sentence.length < 10 || sentence.length > 200) {
                            return null; // Too short or too long, skip
                        }
                        
                        // Check for repetitive patterns (e.g., "word word word")
                        const words = sentence.split(/\s+/);
                        if (words.length < 3) {
                            return null; // Too few words, not a proper sentence
                        }
                        
                        // Check for too many repeated words (indicates weird generation)
                        const wordCounts = {};
                        for (let w of words) {
                            const lower = w.toLowerCase();
                            wordCounts[lower] = (wordCounts[lower] || 0) + 1;
                            if (wordCounts[lower] > 3) {
                                return null; // Too repetitive, skip
                            }
                        }
                        
                        // Ensure the word is in the sentence
                        if (!sentence.toLowerCase().includes(word.toLowerCase())) {
                            return null; // Word not found, skip this generation
                        }
                        
                        // Capitalize first letter
                        if (sentence.length > 0) {
                            sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);
                            // Add period if missing
                            if (!sentence.match(/[.!?]$/)) {
                                sentence += '.';
                            }
                            return sentence;
                        }
                    }
                    
                    // Fallback: try to extract any sentence containing the word
                    const sentences = generatedText.split(/[.!?]/);
                    for (let sent of sentences) {
                        sent = sent.trim();
                        // Better validation: check for reasonable length and word count
                        if (sent.length >= 15 && sent.length <= 200 && 
                            sent.toLowerCase().includes(word.toLowerCase())) {
                            const words = sent.split(/\s+/);
                            if (words.length >= 3) {
                                sent = sent.replace(/^["']|["']$/g, '').trim();
                                if (sent.length > 0) {
                                    sent = sent.charAt(0).toUpperCase() + sent.slice(1);
                                    if (!sent.match(/[.!?]$/)) {
                                        sent += '.';
                                    }
                                    return sent;
                                }
                            }
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error generating sentence:', error);
                    return null;
                }
            }

            // Automatically load CSV on page load
            async function loadCsvOnInit() {
                if (!CSV_URL || !CSV_URL.trim()) {
                    console.log('No CSV URL configured, using default word list');
                    loadNewWord();
                    return;
                }

                try {
                    const response = await fetch(CSV_URL);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const csvText = await response.text();
                    csvWords = parseCsv(csvText);
                    
                    if (csvWords.length === 0) {
                        throw new Error('No words found in CSV file');
                    }

                    // Use CSV words instead of default wordList
                    wordList = csvWords;
                    isCsvLoaded = true;
                    
                    console.log(`Loaded ${csvWords.length} words from CSV`);
                    
                    // Load word after CSV is loaded
                    loadNewWord();
                } catch (error) {
                    console.error('Error loading CSV:', error);
                    // Fall back to default word list if CSV fails
                    console.log('Falling back to default word list');
                    loadNewWord();
                }
            }

            // Parse CSV content and extract words
            function parseCsv(csvText) {
                const words = [];
                const lines = csvText.split('\n');
                
                for (let line of lines) {
                    line = line.trim();
                    if (!line) continue;
                    
                    // Handle CSV format - split by comma, but handle quoted values
                    const columns = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            columns.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    // Add the last column
                    columns.push(current.trim());
                    
                    // Extract all words from all columns (for single-line comma-separated word lists)
                    for (let col of columns) {
                        // Remove quotes if present
                        let word = col.replace(/^"|"$/g, '').trim();
                        if (word) {
                            words.push(word);
                        }
                    }
                }
                
                return words;
            }


            // Set current date
            const now = new Date();
            currentDateEl.textContent = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            // Initialize speech recognition
            function initializeSpeechRecognition() {
                // Check for browser support
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    browserWarningEl.textContent = 'Speech recognition is not supported in this browser. Please try Chrome or Edge.';
                    browserWarningEl.classList.remove('hidden');
                    recordBtn.disabled = true;
                    return false;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();

                // Configure recognition
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;

                // Set up event handlers
                recognition.onstart = function () {
                    console.log('Speech recognition started');
                    transcriptTextEl.textContent = "Listening... Speak now!";
                    lastSpeechTime = null; // Reset - no speech detected yet
                    startSilenceTimer();
                };

                recognition.onresult = function (event) {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    // Process all results
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Update last speech time if we have any transcript
                    if (interimTranscript || finalTranscript) {
                        lastSpeechTime = Date.now();
                        resetSilenceTimer();
                    }

                    // Show interim results
                    if (interimTranscript) {
                        transcriptTextEl.textContent = `Listening... "${interimTranscript}"`;
                    }

                    // Handle final results
                    if (finalTranscript) {
                        console.log('Final transcript:', finalTranscript.trim());
                        handleSpeechResult(finalTranscript.trim());
                        // Auto-stop after getting a result
                        setTimeout(() => {
                            stopRecording();
                        }, 500);
                    }
                };

                recognition.onerror = function (event) {
                    console.error('Speech recognition error:', event.error);

                    if (event.error === 'not-allowed') {
                        transcriptTextEl.textContent = 'Microphone access denied. Please allow microphone access and try again.';
                        browserWarningEl.textContent = 'Microphone access is required for speech practice. Please allow microphone access in your browser settings.';
                        browserWarningEl.classList.remove('hidden');
                    } else if (event.error === 'audio-capture') {
                        transcriptTextEl.textContent = 'No microphone detected. Please check your microphone connection.';
                    } else {
                        transcriptTextEl.textContent = 'Error: ' + event.error;
                    }

                    stopRecording();
                };

                recognition.onend = function () {
                    console.log('Speech recognition ended');
                    clearSilenceTimer();

                    // Only restart if we're still supposed to be recording and haven't timed out
                    if (isRecording) {
                        const timeSinceLastSpeech = Date.now() - lastSpeechTime;

                        // If silence timeout hasn't been reached, restart
                        if (timeSinceLastSpeech < SILENCE_TIMEOUT_MS) {
                            setTimeout(() => {
                                if (isRecording && recognition) {
                                    try {
                                        recognition.start();
                                    } catch (e) {
                                        console.error('Error restarting recognition:', e);
                                        stopRecording();
                                    }
                                }
                            }, 100);
                        } else {
                            // Silence timeout reached, stop recording
                            transcriptTextEl.textContent = "Recording stopped due to silence. Click to record again.";
                            stopRecording();
                        }
                    }
                };

                browserWarningEl.textContent = 'Speech recognition works best in Chrome and Edge. Make sure you\'re in a quiet environment and allow microphone access when prompted.';
                browserWarningEl.classList.remove('hidden');

                return true;
            }

            // Handle speech recognition results
            function handleSpeechResult(transcript) {
                const activeMode = document.querySelector('.practice-btn.active').id;

                if (activeMode === 'repeat-btn') {
                    // For repeat mode, we can't accurately check but we can encourage
                    transcriptTextEl.innerHTML = `You said: "${transcript}"<br><br>Great job! Keep practicing to improve your pronunciation.`;
                } else if (activeMode === 'fill-btn') {
                    // For fill mode, check if the word is in the transcript
                    if (currentWord && transcript.toLowerCase().includes(currentWord.word.toLowerCase())) {
                        transcriptTextEl.innerHTML = `You said: "${transcript}"<br><br>Excellent! You used "${currentWord.word}" correctly!`;
                    } else {
                        transcriptTextEl.innerHTML = `You said: "${transcript}"<br><br>Good attempt! Try to include the word "${currentWord.word}" in your sentence.`;
                    }
                } else if (activeMode === 'create-btn') {
                    // For create mode, just acknowledge
                    transcriptTextEl.innerHTML = `You said: "${transcript}"<br><br>Creative! You're using "${currentWord.word}" in context.`;
                }
            }

            // Start recording function
            function startRecording() {
                if (!recognition) {
                    if (!initializeSpeechRecognition()) {
                        return;
                    }
                }

                try {
                    // Reset state
                    lastSpeechTime = null;
                    clearSilenceTimer();

                    recognition.start();
                    isRecording = true;
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><rect width="4" height="12" x="6" y="2"/></svg> Stop Recording';
                    transcriptTextEl.textContent = "Starting...";
                } catch (e) {
                    console.error('Error starting recognition:', e);
                    transcriptTextEl.textContent = 'Error starting speech recognition. Please try again.';
                    stopRecording();
                }
            }

            // Silence timer functions
            function startSilenceTimer() {
                clearSilenceTimer();
                const startTime = Date.now();
                silenceTimeout = setInterval(() => {
                    if (isRecording) {
                        if (lastSpeechTime) {
                            // User has spoken, check time since last speech
                            const timeSinceLastSpeech = Date.now() - lastSpeechTime;
                            if (timeSinceLastSpeech >= SILENCE_TIMEOUT_MS) {
                                // Silence detected, stop recording
                                transcriptTextEl.textContent = "Recording stopped due to silence. Click to record again.";
                                stopRecording();
                            }
                        } else {
                            // User hasn't spoken yet, check time since recording started
                            const timeSinceStart = Date.now() - startTime;
                            if (timeSinceStart >= SILENCE_TIMEOUT_MS) {
                                // No speech detected since start, stop recording
                                transcriptTextEl.textContent = "No speech detected. Click to record again.";
                                stopRecording();
                            }
                        }
                    }
                }, 500); // Check every 500ms
            }

            function resetSilenceTimer() {
                // Timer is already running, no need to restart
                // The interval will check the timeSinceLastSpeech
            }

            function clearSilenceTimer() {
                if (silenceTimeout) {
                    clearInterval(silenceTimeout);
                    silenceTimeout = null;
                }
            }

            // Stop recording function
            function stopRecording() {
                isRecording = false;
                clearSilenceTimer();
                lastSpeechTime = null;
                if (recognition) {
                    try {
                        recognition.stop();
                    } catch (e) {
                        console.error('Error stopping recognition:', e);
                    }
                }
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 12c2.21 0 4-1.79 4-4V4c0-2.21-1.79-4-4-4S4 1.79 4 4v4c0 2.21 1.79 4 4 4zm0 1c-2.76 0-5-2.24-5-5V4c0-2.76 2.24-5 5-5s5 2.24 5 5v4c0 2.76-2.24 5-5 5z"/><path d="M0 7.5v1c0 .28.22.5.5.5H2v-2H.5c-.28 0-.5.22-.5.5zM16 7.5c0-.28-.22-.5-.5-.5H14v2h1.5c.28 0 .5-.22.5-.5v-1zM4.5 13.5c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5h1c.28 0 .5-.22.5-.5V14c0-.28-.22-.5-.5-.5h-1zM11.5 13.5c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5h1c.28 0 .5-.22.5-.5V14c0-.28-.22-.5-.5-.5h-1zM8 15c-.28 0-.5.22-.5.5v1c0 .28.22.5.5.5s.5-.22.5-.5v-1c0-.28-.22-.5-.5-.5z"/></svg> Start Recording';
            }

            // Fetch word data from Free Dictionary API
            async function fetchWordData(word) {
                try {
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                    if (!response.ok) {
                        throw new Error('Word not found');
                    }
                    const data = await response.json();
                    return data[0];
                } catch (error) {
                    console.error('Error fetching word data:', error);
                    return null;
                }
            }

            // Get a random word
            function getRandomWord() {
                return wordList[Math.floor(Math.random() * wordList.length)];
            }

            // Format word data for display
            async function formatWordData(apiData) {
                if (!apiData) return null;

                const word = apiData.word;
                let pronunciation = '';
                let definition = '';
                let example = '';

                // Get pronunciation
                if (apiData.phonetic) {
                    pronunciation = apiData.phonetic;
                } else if (apiData.phonetics && apiData.phonetics.length > 0) {
                    pronunciation = apiData.phonetics[0].text || '';
                }

                // Get definition and example from the first meaning
                if (apiData.meanings && apiData.meanings.length > 0) {
                    const firstMeaning = apiData.meanings[0];
                    if (firstMeaning.definitions && firstMeaning.definitions.length > 0) {
                        const firstDefinition = firstMeaning.definitions[0];
                        definition = firstDefinition.definition;
                        example = firstDefinition.example || '';
                    }
                }

                // Generate example sentence using local LLM if fully loaded and ready
                // Only use LLM if it's completely ready, otherwise use default API example
                if (llmReady && !llmLoading && definition) {
                    try {
                        const generatedExample = await generateExampleSentence(word, definition);
                        if (generatedExample) {
                            example = generatedExample;
                        }
                        // If generation fails or returns null, keep the API example
                    } catch (error) {
                        console.log('LLM generation failed, using API example:', error);
                        // Keep the API example if LLM fails
                    }
                }
                // If LLM is not ready or still loading, use the API example (already set above)

                return {
                    word: word,
                    pronunciation: pronunciation,
                    definition: definition,
                    example: example
                };
            }

            // Create skeleton loader element
            function createSkeletonLoader() {
                let loader = document.getElementById('skeleton-loader');
                if (!loader) {
                    loader = document.createElement('div');
                    loader.id = 'skeleton-loader';
                    loader.className = 'skeleton-loader';
                    const container = exampleEl.parentElement;
                    if (container) {
                        container.style.position = 'relative';
                        // Create skeleton lines
                        loader.innerHTML = `
                            <div class="skeleton-line long"></div>
                            <div class="skeleton-line medium"></div>
                            <div class="skeleton-line short"></div>
                        `;
                        container.appendChild(loader);
                    }
                }
                return loader;
            }

            // Animate character morphing
            async function morphSentence(oldText, newText) {
                return new Promise((resolve) => {
                    // Remove quotes for processing
                    const oldClean = oldText.replace(/^["']|["']$/g, '').trim();
                    const newClean = newText.replace(/^["']|["']$/g, '').trim();
                    
                    // Split into characters
                    const oldChars = oldClean.split('');
                    const newChars = newClean.split('');
                    const maxLength = Math.max(oldChars.length, newChars.length);
                    
                    // Create initial HTML with old characters
                    let html = '"';
                    for (let i = 0; i < maxLength; i++) {
                        const char = i < oldChars.length ? oldChars[i] : (i < newChars.length ? newChars[i] : ' ');
                        const displayChar = char === ' ' ? '\u00A0' : char;
                        html += `<span class="char-morph" data-index="${i}" data-old="${oldChars[i] || ''}" data-new="${newChars[i] || ''}">${displayChar}</span>`;
                    }
                    html += '"';
                    exampleEl.innerHTML = html;

                    // Morph characters one by one with smooth animation
                    const charDelay = 25; // milliseconds between each character
                    let completed = 0;
                    let resolved = false;
                    const totalChars = maxLength;

                    function checkComplete() {
                        completed++;
                        if (completed >= totalChars && !resolved) {
                            resolved = true;
                            resolve();
                        }
                    }

                    function processChar(index) {
                        const span = exampleEl.querySelector(`[data-index="${index}"]`);
                        if (!span) {
                            checkComplete();
                            return;
                        }

                        const oldChar = span.getAttribute('data-old');
                        const newChar = span.getAttribute('data-new');

                        if (index < oldChars.length && index < newChars.length) {
                            // Both old and new exist at this position
                            if (oldChar !== newChar) {
                                // Morph: fade out old, fade in new
                                span.classList.add('morphing');
                                setTimeout(() => {
                                    span.textContent = newChar === ' ' ? '\u00A0' : newChar;
                                    span.classList.remove('morphing');
                                    span.classList.add('morphing-in');
                                    setTimeout(() => {
                                        span.classList.remove('morphing-in');
                                        checkComplete();
                                    }, 400);
                                }, 200);
                            } else {
                                // Same character, no change needed
                                checkComplete();
                            }
                        } else if (index < oldChars.length && index >= newChars.length) {
                            // Old character exists but new doesn't - fade out
                            span.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                            span.style.opacity = '0';
                            span.style.transform = 'scale(0.5)';
                            setTimeout(() => {
                                span.remove();
                                checkComplete();
                            }, 300);
                        } else if (index >= oldChars.length && index < newChars.length) {
                            // New character exists but old doesn't - fade in
                            span.textContent = newChar === ' ' ? '\u00A0' : newChar;
                            span.style.opacity = '0';
                            span.style.transform = 'scale(0.5) translateY(-5px)';
                            setTimeout(() => {
                                span.classList.add('morphing-in');
                                setTimeout(() => {
                                    span.classList.remove('morphing-in');
                                    checkComplete();
                                }, 400);
                            }, 50);
                        } else {
                            checkComplete();
                        }
                    }

                    // Process all characters with delay
                    for (let i = 0; i < maxLength; i++) {
                        setTimeout(() => processChar(i), i * charDelay);
                    }
                });
            }

            // Regenerate example sentence with skeleton loader
            async function regenerateExample() {
                if (!currentWord || !currentWord.definition) {
                    return;
                }

                // Reset cancellation flag
                regenerateCancelled = false;

                // Show loading state immediately
                regenerateBtn.classList.add('loading');
                regenerateBtn.disabled = true;
                
                // Disable Next Word button during regeneration
                nextBtn.disabled = true;
                
                // Disable audio/pronunciation button during regeneration
                audioBtn.disabled = true;

                // Create skeleton loader first
                const skeletonLoader = createSkeletonLoader();
                
                // Hide the current text immediately
                exampleEl.style.opacity = '0.3';
                
                // Show skeleton loader IMMEDIATELY - synchronously, no await
                skeletonLoader.style.display = 'block';
                skeletonLoader.style.opacity = '1';
                skeletonLoader.classList.add('active');
                
                // Force immediate DOM update by accessing offsetWidth (triggers reflow)
                void skeletonLoader.offsetWidth;
                void exampleEl.offsetWidth;
                
                // CRITICAL: Use double requestAnimationFrame to ensure browser paints skeleton
                // But check for cancellation during this wait
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        // Check if cancelled during first frame
                        if (regenerateCancelled) {
                            resolve();
                            return;
                        }
                        requestAnimationFrame(() => {
                            // Check if cancelled during second frame
                            if (regenerateCancelled) {
                                resolve();
                                return;
                            }
                            // One more microtask to ensure rendering
                            Promise.resolve().then(() => {
                                resolve();
                            });
                        });
                    });
                });

                // Check if cancelled before starting async work
                if (regenerateCancelled) {
                    cleanupRegeneration(skeletonLoader);
                    return;
                }

                try {
                    let newExample = null;

                    // Try to generate using LLM if available
                    if (llmReady && !llmLoading && currentWord.definition && !regenerateCancelled) {
                        try {
                            newExample = await generateExampleSentence(currentWord.word, currentWord.definition);
                        } catch (error) {
                            console.log('LLM generation failed:', error);
                        }
                    }

                    // Check if cancelled after LLM generation
                    if (regenerateCancelled) {
                        cleanupRegeneration(skeletonLoader);
                        return;
                    }

                    // If LLM didn't generate or isn't available, try fetching from API again
                    if (!newExample && !regenerateCancelled) {
                        const apiData = await fetchWordData(currentWord.word);
                        if (apiData && apiData.meanings && apiData.meanings.length > 0) {
                            const firstMeaning = apiData.meanings[0];
                            if (firstMeaning.definitions && firstMeaning.definitions.length > 0) {
                                // Try to get a different example from other definitions
                                for (let meaning of apiData.meanings) {
                                    if (meaning.definitions) {
                                        for (let def of meaning.definitions) {
                                            if (def.example && def.example !== currentWord.example) {
                                                newExample = def.example;
                                                break;
                                            }
                                        }
                                        if (newExample) break;
                                    }
                                }
                                // If no different example found, use the first one
                                if (!newExample && firstMeaning.definitions[0].example) {
                                    newExample = firstMeaning.definitions[0].example;
                                }
                            }
                        }
                    }

                    // Check if cancelled after API fetch
                    if (regenerateCancelled) {
                        cleanupRegeneration(skeletonLoader);
                        return;
                    }

                    // Hide skeleton loader and show new text directly (no morphing)
                    skeletonLoader.classList.remove('active');
                    skeletonLoader.style.display = 'none';
                    skeletonLoader.style.opacity = '0';
                    exampleEl.style.opacity = '1';

                    // Update the example directly without animation
                    if (newExample && !regenerateCancelled) {
                        currentWord.example = newExample;
                        exampleEl.textContent = `"${newExample}"`;
                        // Update practice text as well
                        practiceTextEl.textContent = `"${newExample}"`;
                    } else if (!regenerateCancelled) {
                        // Fallback message
                        const fallbackText = `"Try using "${currentWord.word}" in your own sentence!"`;
                        exampleEl.textContent = fallbackText;
                    }
                } catch (error) {
                    if (!regenerateCancelled) {
                        console.error('Error regenerating example:', error);
                        // Hide skeleton loader on error
                        skeletonLoader.classList.remove('active');
                        skeletonLoader.style.display = 'none';
                        skeletonLoader.style.opacity = '0';
                        exampleEl.style.opacity = '1';
                        const errorText = `"${currentWord.example || `This is an example sentence for ${currentWord.word}.`}"`;
                        exampleEl.textContent = errorText;
                    }
                } finally {
                    if (!regenerateCancelled) {
                        // Ensure skeleton loader is always hidden
                        const loader = document.getElementById('skeleton-loader');
                        if (loader) {
                            loader.classList.remove('active');
                            loader.style.display = 'none';
                            loader.style.opacity = '0';
                        }
                        // Remove loading state
                        regenerateBtn.classList.remove('loading');
                        regenerateBtn.disabled = false;
                        // Re-enable Next Word button
                        nextBtn.disabled = false;
                        // Re-enable audio button
                        audioBtn.disabled = false;
                        // Reset example opacity
                        exampleEl.style.opacity = '1';
                    }
                }
            }

            // Cleanup function for regeneration
            function cleanupRegeneration(skeletonLoader) {
                if (skeletonLoader) {
                    skeletonLoader.classList.remove('active');
                    skeletonLoader.style.display = 'none';
                    skeletonLoader.style.opacity = '0';
                }
                const loader = document.getElementById('skeleton-loader');
                if (loader) {
                    loader.classList.remove('active');
                    loader.style.display = 'none';
                    loader.style.opacity = '0';
                }
                regenerateBtn.classList.remove('loading');
                regenerateBtn.disabled = false;
                // Re-enable Next Word button
                nextBtn.disabled = false;
                // Re-enable audio button
                audioBtn.disabled = false;
                exampleEl.style.opacity = '1';
            }

            // Display word
            function displayWord(wordData) {
                currentWord = wordData;

                wordEl.textContent = wordData.word;
                pronunciationEl.textContent = wordData.pronunciation || '/pronunciation/';
                definitionEl.textContent = wordData.definition || 'Definition not available.';

                if (wordData.example) {
                    exampleEl.textContent = `"${wordData.example}"`;
                } else {
                    exampleEl.textContent = `Try using "${wordData.word}" in your own sentence!`;
                }

                // Update practice text
                practiceTextEl.textContent = `"${wordData.example || `This is an example sentence for ${wordData.word}.`}"`;

                // Reset practice mode to repeat mode
                setActivePracticeMode('repeat-btn');
                practiceInstructionEl.textContent = "Listen to the sentence, then click record and repeat it";
                transcriptTextEl.textContent = "Your speech will appear here...";
                recordingSectionEl.classList.remove('hidden');
                inputSectionEl.classList.add('hidden');
                feedbackEl.classList.add('hidden');
                practiceInputEl.value = '';
                practiceTextareaEl.value = '';
                practiceInputEl.classList.remove('hidden');
                practiceTextareaEl.classList.add('hidden');
                stopRecording();

                // Set up audio button
                audioBtn.onclick = function () {
                    speakText(wordData.word);
                };
            }

            // Text-to-speech function
            function speakText(text) {
                if (synth.speaking) {
                    synth.cancel();
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1;
                utterance.volume = 1;

                synth.speak(utterance);
            }

            // Speak example sentence
            function speakExample() {
                if (currentWord && currentWord.example) {
                    speakText(currentWord.example);
                } else if (currentWord) {
                    speakText(`This is an example sentence for ${currentWord.word}`);
                }
            }

            // Fade transition helper functions
            function fadeOut(element, callback) {
                element.classList.remove('show');
                setTimeout(() => {
                    element.classList.add('hidden');
                    if (callback) callback();
                }, 500); // Match transition duration
            }

            function fadeIn(element) {
                element.classList.remove('hidden');
                // Force reflow to ensure transition works
                void element.offsetWidth;
                element.classList.add('show');
            }

            // Load a new word
            async function loadNewWord() {
                // IMMEDIATELY cancel any ongoing regeneration - don't wait for anything
                regenerateCancelled = true;
                
                // Clean up any active skeleton loader IMMEDIATELY (synchronously)
                const skeletonLoader = document.getElementById('skeleton-loader');
                if (skeletonLoader) {
                    skeletonLoader.classList.remove('active');
                    skeletonLoader.style.display = 'none';
                    skeletonLoader.style.opacity = '0';
                }
                
                // Reset example element opacity IMMEDIATELY
                exampleEl.style.opacity = '1';
                
                // Reset regenerate button state IMMEDIATELY
                regenerateBtn.classList.remove('loading');
                regenerateBtn.disabled = false;
                
                // IMMEDIATELY hide word container and show loading screen (no waiting)
                // Don't wait for fade animations - show loading immediately
                wordContainerEl.classList.add('hidden');
                wordContainerEl.classList.remove('show');
                errorEl.classList.add('hidden');
                
                // Show loading screen IMMEDIATELY
                loadingEl.classList.remove('hidden');
                loadingEl.classList.add('show');
                
                // Force immediate rendering - trigger reflow
                void loadingEl.offsetWidth;
                void wordContainerEl.offsetWidth;
                
                // Start async work in next tick - don't block UI updates
                // Use setTimeout to ensure UI is painted first
                setTimeout(async () => {

                    const randomWord = getRandomWord();

                    try {
                        const apiData = await fetchWordData(randomWord);
                        if (apiData) {
                            const formattedData = await formatWordData(apiData);
                            if (formattedData) {
                                displayWord(formattedData);
                                // Fade out loading, then fade in word container
                                fadeOut(loadingEl, () => {
                                    fadeIn(wordContainerEl);
                                });
                            } else {
                                throw new Error('Could not format word data');
                            }
                        } else {
                            throw new Error('No data received from API');
                        }
                    } catch (error) {
                        console.error('Error loading word:', error);
                        // Use fallback word data
                        const fallbackWord = {
                            word: randomWord,
                            pronunciation: '/pronunciation/',
                            definition: `The meaning of ${randomWord}.`,
                            example: `This is an example sentence using the word ${randomWord}.`
                        };
                        displayWord(fallbackWord);
                        // Fade out loading, then fade in word container
                        fadeOut(loadingEl, () => {
                            fadeIn(wordContainerEl);
                        });
                    }
                }, 0);
            }

            // Practice mode switching
            repeatBtn.addEventListener('click', function () {
                setActivePracticeMode('repeat-btn');
                if (currentWord && currentWord.example) {
                    practiceTextEl.textContent = `"${currentWord.example}"`;
                } else {
                    practiceTextEl.textContent = `"This is an example sentence for ${currentWord.word}."`;
                }
                practiceInstructionEl.textContent = "Listen to the sentence, then click record and repeat it";
                transcriptTextEl.textContent = "Your speech will appear here...";
                recordingSectionEl.classList.remove('hidden');
                inputSectionEl.classList.add('hidden');
                feedbackEl.classList.add('hidden');
                stopRecording();
                speakExample();
            });

            fillBtn.addEventListener('click', function () {
                setActivePracticeMode('fill-btn');
                if (currentWord && currentWord.example) {
                    // Create a fill-in-the-blank from the example sentence
                    const example = currentWord.example;
                    let blankSentence = example;

                    // Replace the word with blank
                    const wordRegex = new RegExp(`\\b${currentWord.word}\\b`, 'gi');
                    blankSentence = example.replace(wordRegex, '__________');

                    practiceTextEl.textContent = `"${blankSentence}"`;
                } else {
                    practiceTextEl.textContent = `"Finding this beautiful app was pure __________."`;
                }
                practiceInstructionEl.textContent = `Type the word "${currentWord.word}" to complete the sentence`;
                recordingSectionEl.classList.add('hidden');
                inputSectionEl.classList.remove('hidden');
                feedbackEl.classList.add('hidden');
                practiceInputEl.value = '';
                practiceInputEl.placeholder = `Type "${currentWord.word}" here...`;
                practiceInputEl.classList.remove('hidden');
                practiceTextareaEl.classList.add('hidden');
                stopRecording();
            });

            createBtn.addEventListener('click', function () {
                setActivePracticeMode('create-btn');
                practiceTextEl.textContent = `Create your own sentence using "${currentWord.word}"`;
                practiceInstructionEl.textContent = `Type a sentence that includes the word "${currentWord.word}"`;
                recordingSectionEl.classList.add('hidden');
                inputSectionEl.classList.remove('hidden');
                feedbackEl.classList.add('hidden');
                practiceTextareaEl.value = '';
                practiceTextareaEl.placeholder = `Type a sentence using "${currentWord.word}" here...`;
                practiceInputEl.classList.add('hidden');
                practiceTextareaEl.classList.remove('hidden');
                stopRecording();
            });

            function setActivePracticeMode(activeId) {
                // Remove active class from all buttons
                repeatBtn.classList.remove('active');
                fillBtn.classList.remove('active');
                createBtn.classList.remove('active');

                // Add active class to clicked button
                document.getElementById(activeId).classList.add('active');
            }

            // Record button functionality
            recordBtn.addEventListener('click', function () {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });

            // Submit button functionality
            submitBtn.addEventListener('click', function () {
                handleSubmit();
            });

            // Allow Enter key to submit (but not for textarea, use Ctrl+Enter)
            practiceInputEl.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    handleSubmit();
                }
            });

            practiceTextareaEl.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    handleSubmit();
                }
            });

            // Handle form submission
            function handleSubmit() {
                const activeMode = document.querySelector('.practice-btn.active').id;
                let userInput = '';

                if (activeMode === 'create-btn') {
                    userInput = practiceTextareaEl.value.trim();
                } else {
                    userInput = practiceInputEl.value.trim();
                }

                if (!userInput) {
                    feedbackEl.textContent = 'Please enter your answer.';
                    feedbackEl.className = 'feedback incorrect';
                    feedbackEl.classList.remove('hidden');
                    return;
                }

                if (activeMode === 'fill-btn') {
                    // Check if the input matches the word (case insensitive)
                    if (userInput.toLowerCase() === currentWord.word.toLowerCase()) {
                        feedbackEl.textContent = `Correct! "${currentWord.word}" is the right answer. Great job!`;
                        feedbackEl.className = 'feedback correct';
                        feedbackEl.classList.remove('hidden');
                    } else {
                        feedbackEl.textContent = `Not quite. The correct answer is "${currentWord.word}". Try again!`;
                        feedbackEl.className = 'feedback incorrect';
                        feedbackEl.classList.remove('hidden');
                    }
                } else if (activeMode === 'create-btn') {
                    // Check if the sentence contains the word
                    const inputLower = userInput.toLowerCase();
                    const wordLower = currentWord.word.toLowerCase();

                    if (inputLower.includes(wordLower)) {
                        feedbackEl.textContent = `Excellent! You used "${currentWord.word}" correctly in your sentence: "${userInput}"`;
                        feedbackEl.className = 'feedback correct';
                        feedbackEl.classList.remove('hidden');
                    } else {
                        feedbackEl.textContent = `Your sentence doesn't include "${currentWord.word}". Try again and make sure to use the word in your sentence!`;
                        feedbackEl.className = 'feedback incorrect';
                        feedbackEl.classList.remove('hidden');
                    }
                }
            }

            // Regenerate button - generate new example sentence
            regenerateBtn.addEventListener('click', function () {
                regenerateExample();
            });

            // Next button - load a new word
            nextBtn.addEventListener('click', function () {
                loadNewWord();
            });

            // Initialize the app - automatically load CSV and LLM on page load
            initializeLLM();
            loadCsvOnInit();
        });
    </script>
</body>

</html>